package dynamic;
/*
 <문제92 빌딩 순서 구하기>
 상근이가 살고 있는 동네에는 빌딩 N개가 1줄로 세워져 있다.
 모든 빌딩의 높이는 1보다 크거나 같고, N보다 작거나 같으며, 높이가 같은 빌딩은 없다.
 상근이는 학교 가는 길에 가장 왼쪽에 서서 빌딩을 몇 개 볼 수 있는 지 봤고, 집에 돌아오는 길에는 가장 오른쪽에 서서 빌딩을 몇 개 볼 수 있는지 봤다.
 상근이는 가장 왼쪽과 오른쪽에서만 빌딩을 봤기 때문에 빌딩이 어떤 순서로 위치해 잇는지는 알 수가 없다.
 빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어졌을 때 가능한 빌딩 순서의 경우의 수를 구하는 프로그램을 작성하시오.
 예를 들어 N=5, L=3, R=2일 때 가능한 빌딩의 배치 중 하나는 1 3 5 2 4이다.
 */
/*
 <출제 포인트>
 (1) 작은 부분으로 큰 부분의 문제를 어떻게 해결할 것인가
  -> N 값이 문제를 부분 문제로 나누는 역할을 해야함
  -> 일정한 규칙에 따라 단순화를 어떻게 할 것인지 : 나는 경우의 수를 모두 셌는데 단순화 시킬 수 있어야 함. 규칙 발견하기 위해 세야할 경우도 있지만 이경우는 아니었음.
  -> 가장 작은 것은 명확하다 ( 가장 작은 것을 추가하는 경우)
  -> 3차원 행렬

  크기가 가장 큰 빌딩은 가운데에 위치하면 경우의 수를 구하기 애매하다

  크기가 가장 작은 빌딩을 양 끝 , 가운데 배치하는 경우를 생각해보자

  (1) N개의 빌딩이 왼쪽에 L개, 오른쪽에 R개가 보인다고 가정하면 N-1개의 빌딩에서
  왼쪽에 빌딩을 추가할 때 왼쪽 빌딩이 1개 증가하므로 이전 경우의 수는 아래와 같다.
  D[N-1][L-1][R]

  (2) 오른쪽의 경우는 반대로
  D[N-1][L][R-1]

  (3) 가운데 빌딩을 추가하는 경우: 보이는 빌딩 수는 증가하지 않지만 . N-2개의 위치에서 배치할 수 있다.
  D[N-1][L][R] * (N - 2)

  실제 빌딩이 큰 것만 생길 수 있는것과 별개의 공식 도출 과정이다.(경우가 자명한 것)
  결론 D[N][L][R] = D[N-1][L-1][R] + D[N-1][L][R-1] + D[N-1][L][R] * (N-2)
 */
/*

 1 1 1 1 1
   1 1 1 1
   1 1   1
     1   1
     1   
이차원 배열로 해결
S[N][L][R] -> 빌딩이 N개일 대 L과 R에서 보이는 빌딩의 수에 따라는 빌딩 높이의 경우의 수
S[1][1][1] = 1

S[2][1][1] = 0
S[2][1][2] = 1  1 2
S[2][2][1] = 1  2 1
S[2][2][2] = 0

B[3][2][2] = B[2][1][2] + B[2][2][1] + B[2][2][2] * (0)

S[3][1][1] = 0     1개만 보이려면 무조건 가장 큰 빌딩 양 쪽에서 모두 1개일수는 없음 
S[3][1][2] = 1     3 1 2 -> 1개만 보이려면 무조건 가장 큰 빌딩
S[3][1][3] = 1     3 2 1  
S[3][2][1] = 1     2 1 3 
S[3][2][2] = 2     1 3 2   2 3 1
S[3][2][3] = 0     한쪽이 빌딩의 개수만큼 보이면 반대쪽은 무조건 1
S[3][3][3] = 0

S[4][1][1] = 0
S[4][1][2] = 2        4 1 2 3   4 2 1 3
S[4][1][3] = 2        4 1 3 2   4 2 3 1
S[4][1][4] = 1        4 3 2 1
S[4][2][1] = 2        3 1 2 4   3 2 1 4
S[4][2][2] = 6        3 4 1 2  | 3 1 4 2 | 2 4 1 3 |  2 1 4 3 |  1 4 2 3 |  3 2 4 1
S[4][2][3] = 3        1 4 3 2  | 2 4 3 1  | 3 4 2 1 | 
S[4][2][4] = 0      한쪽이 빌딩의 개수만큼 보이면 반대쪽은 무조건 1
S[4][3][1] = 2
S[4][3][2] = 3
S[4][3][3] = 0
S[4][3][4] = 0      한쪽이 빌딩의 개수만큼 보이면 반대쪽은 무조건 1
S[4][4][1]= 1
S[4][4][2] = 0
S[4][4][3] = 0
S[4][4][4] = 0



S[3]

 */

import java.util.*;

public class Question92 {
    public static long mod = 1000000007;
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int L = sc.nextInt();
        int R = sc.nextInt();

        long B[][][] = new long[N+1][L+1][R+1];

        B[1][1][1] = 1;
        for(int i = 2; i <= N; i++){
            for(int j = 1; j <= L; j++){
                for(int k = 1; k <= R; k++){
                    B[i][j][k] = (B[i-1][j-1][k] + B[i-1][j][k-1] + B[i-1][j][k] * (i-2) ) % mod;
                }
            }
        }
        System.out.println(B[N][L][R]);
    }
}

package dynamic;

/*
 <문제89 연속된 정수의 합 구하기>
 n개의 정수로 이뤄진 임의의 수열이 주어진다. 
 이 중 연속된 몇 개의 수를 선택해 구할 수 있는 합 중 가장 큰 합을 구하려고 한다.
 단, 수는 1개 이상 선택해야 한다.
 또한 수열에서 수를 1개 제거할 수 있다(제거하지 않아도 된다).
 예를 들어 10, -4, 3, 1, 5, 6, -35, 12, 21, -1이라는 수열이 주어졌다고 가정해 보자.
 여기서 수를 제거하지 않았을 때의 정답은 12 + 21 = 33이 정답이 된다.
 만약 -35를 제거한다면 수열은 10, -4, 3, 1, 5, 6, 12, 21, -1이 되고, 여기서 정답은
 10 - 4 + 3 + 1 + 5 + 6 + 12 + 21 = 54가 된다.
 */
/*
<출제 포인트>
(1) 동적 계획법의 이해 및 구현
-점화식을 잘 세워야한다.
-> 동적 계획법은 큰 문제를 작은 문제로 나누고, 이러한 작은 문제를 해결해 궁극적으로 큰 문제를 해결하는 방법.

- 잘못된 나의 점화식 - D[N] 0에서 N까지 길이에서 연속으로 수를 선택하여 구할 수 있는 최대 합
-> 맨 앞의 수를 선택한 후 아무것도 선택하지 않는게 가장 큰 값이 된다.

- 적절한 점화식 - D[N] : 0에서 N까지 길이에서 N을 포함하여 연속으로 수를 선택하여 구할 수 있는 최대 합
 L[N - 1] + R[N + 1] : N을 1개 제거한 최댓값을 구하는 효과
 
 L[N] : 왼쪽에서부터 N을 포함한 최대 연속 합을 나타냄
 -> L[i] = Math.max(A[i], L[i-1] + A[i])
 R[N] : 오른쪽에서부터 N을 포함한 최대 연속합
 -> R[i] = Math.max(A[i] , R[i + 1] + A[i])

 Result = Math.max(result, L[i-1] + R[i+1])

 (2) 나의 풀이
 오른쪽 다 구해보고 | 왼쪽도 다 구해봄
 근데 적절한 점화식의 의미를 도출하지 못함 -> N 값이 문제를 부분 문제로 나누는데 역할을 못함(현재의 값과 ,이전까지의 값을 비교해야함)
                                        -> 가운데 빼는 걸 생각을 못함(숫자 하나 제거하는 걸 따로하려고 했음)

 (3) 나름대로의 유형 정의 : 양방향에서 구하는 연속 합 구하기
                            현재의 값과 이전까지의 값의 합을 비교하는 문제
 */
 

/*
 sum = 54 - 35 = 19
 D[0] : 0번째 수부터 연속으로 더함 : 19
 D[1] : 1번째 수부터 연속으로 더한 수와 이전 수를 비교 : Max(D[0], 9): 19
 D[2] : 2번째 수부터 연속으로 더한 수와 이전 수를 비교 : Max(D[1], 13) : 19
 D[3] : Max(D[2], 10) : 19
 D[4] : Max(D[3], 9) : 19
 D[5] : Max(D[4], 4) : 19
 D[6] : Max(D[5], -2) : 19
 D[7] : Max(D[6], 33) : 33
 D[8] : Max(D[7], 21) : 33
 D[9] : Max(D[8], 0) : 33
 D[10] : Max(D[9]) ... 뒤부터 더했네
 */

import java.util.*;

public class Question89 {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int A[] = new int[N];
        //왼쪽에서부터 N의 자리 수를 포함한 연속된 수열의 합
        int L[] = new int[N];
        //오른쪽에서부터 N의 자리 수를 포함한 연속된 수열의 합
        int R[] = new int[N];
        //숫자 입력
        for(int i = 0; i < N; i++){
            A[i] = sc.nextInt();
        }
        L[0] = A[0];
        int result = L[0];
        for(int i = 1; i < N; i++){
            L[i] = Math.max(A[i], L[i-1] + A[i]);
            // 삭제하지 않는 배열에서 최댓값을 구함
            result = Math.max(result, L[i]);
        }
        //인덱스 주의 : 나중에 합은 원래 배열 인덱스 순으로  구해야 함
        R[N-1] = A[N-1];
        for(int i = N-2; i >= 0; i--){
            R[i] = Math.max(A[i], R[i + 1] + A[i]);
        }

        for(int i = 1; i < N -1; i++){
            result = Math.max(result, L[i-1] + R[i+1]);
        }
        System.out.println(result);
    }
}

package dynamic;
/*
 <동적 계획법이란>
 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법을 뜻합니다.
 */

 /*
  <동적 계획법의 원리와 구현 방식>
  (1) 큰문 제를 작은 문제로 나눌 수있어야 한다.
  (2) 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
  (3) 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용한다.
      이를 메모제이션 기법이라고 한다.
  (4) 동적 계획법은 톱-다운 | 바텀-업 방식으로 구현할 수 있다.

  ex) 피보나치 수열 공식 : D[N] = D[N-1] + D[N-2]
  */

  /*
   <동적 계획법 핵심>
   (1) 동적 계획법 가능한지 확인: 원리와 구현 방식 참고
   (2) 점화식 세우기
   (3) 메모제이션 원리: DP 테이블에 저장해놓고 사용
   (4) 톱-다운(주로 재귀함수) | 바텀-업(반복문) 이해하기
   */

   /*
    <문제84 정수를 1로 만들기>
    정수 X에 사용할 수 있는 연산은 다음 3가지다.
    1. X가 3으로 나누어떨어지면 3을 ㅗ나눈다.
    2. X가 2로 나누어떨어지면 2로 나눈다.
    3. 1을 뺀다

    정수 N이 주어졌을 때 위와 같은 연산 3개를 적절히 사용해 1을 만들려고 한다.
    연산을 사용하는 횟수의 최솟값을 출력하시오.
    */

    /*
     <출제 포인트>
     (1) 동적 계획법 이해 및 구현
     -1 왜 바텀업으로 햇는지 : 하나 하나 비교하기에는 바텀업이 좋다.
     -2 톱다운도 가능 : 대신 비교문이 많아진다.
     */
     /*
      <몰랐던 점>
      작아지는 것만 신경을 씀, 속성값  비교 필요함
      */
import java.util.*;
public class Question84 {
    static int N;
    static int D[];
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();

        //D[i] : i 에서 1로만드는데 걸리는 최소 연산 횟수
        D = new int[N+1];
        D[1] = 0;
        
        for(int i =2; i < N + 1; i++){
            //3가지 경우를 모두 비교 함
            D[i] = D[i - 1] + 1; // 1을 더하는게 더 작은 경우 그냥 D[i] 씀
            if(i % 2 == 0){ 
                D[i] = Math.min(D[i], D[i / 2] + 1);
            }
            if(i % 3 == 0){
                D[i] = Math.min(D[i], D[i / 3] + 1);
            }
        }
        System.out.println(D[N]);
    }

}
package dynamic;

/*
 <문제88 계단 수 구하기>
 45,656이라는 수를 살펴보자.
 이 수의 인접한 모든 자릿수의 차이는 1이다.
 이를 '계단 수'라고 한다.
 세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.
 N이 주어질 때 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오
 (0으로 시작하는 수는 없다)
 */

/*
 <출제 포인트>
 (1) 동적 계획법 이해 및 구현
 - 어떤 수를 저장할 지(작은 수부터 저장)
 - 2차원 배열 사용 방법 : ㅁ
   D[N][H] : 길이가 N인 계단에서 H높이로 종료되는 계단 수를 만들 수 있는 경우의 수 (높은 자리부터 채운다)

   D[i][H] = D[i - 1][H + 1] : H = 0
   D[i][H] = D[i - 1][H - 1] : H = 9
   D[i][H] = D[i - 1][H - 1] + D[i - 1][H + 1] : H = 1 ~ 8

   예) D[1][1] = 1 D[1][2] = 1 D[1][3] = 1 D[1][4] = 1 D[1][5] = 1 D[1][6] = 1 D[1][7] = 1 D[1][8] = 1 D[1][9] = 1 

   ->내가 생각하지 못한점 배열을 하나만 쓰니깐 경우의 수가 복잡해짐 저장도 안되고

 */

 /*
 

 if 1 ~ N 
 D[1] = 1
 D[2] = 3
 D[3] = 9
 D[4] = 26
 D[5] = 75 -> 71

    0, 9가 아닌경우
    2 | 12 | 012 | 0012 | 
                        | 10012

                 | 1012 | 
                        | 11012
                        | 21012

           | 112 | 0112 | 
                        | 10112

                 | 1112 | 
                        | 11112
                        | 21112

                 | 2112 | 12112
                        | 22112
                        | 32112

           | 212 | 1212 | xxx
                        | xxx
                        | xxx

                 | 2212 | xxx
                        | xxx
                        | xxx

                 | 3212 | xxx
                        | xxx
                        | xxx

      | 22 | 122 | 0122 | xxx
                        | xxx

                 | 1122 | xxx
                        | xxx
                        | xxx

                 | 2122 | xxx
                        | xxx
                        | xxx

           | 222 | 1222 | xxx
                        | xxx
                        | xxx
                 | 2222 | xxx
                        | xxx
                        | xxx
                 | 3222 | xxx
                        | xxx
                        | xxx

           | 322 | 2322 | xxx
                        | xxx
                        | xxx
                 | 3322 | xxx
                        | xxx
                        | xxx

                 | 4322 | xxx
                        | xxx
                        | xxx

      | 32 | 232 | 1232 | xxx
                        | xxx
                        | xxx

                 | 2232 | xxx
                        | xxx
                        | xxx

                 | 3232 | xxx
                        | xxx
                        | xxx

           | 332 | 2332 | xxx
                        | xxx
                 | 3332
                 | 4332

           | 432 | 3432
                 | 4432
                 | 5432

    0인 경우 2가지밖에 못나옴
    1 | 01 | 001 | 0001
                 | 1001

           | 101 | 0101
                 | 1101
                 | 2101

        11 | 011
           | 111
           | 211

        21 | 121
           | 221
           | 321

    --- 9인 경우 2가지밖에 못나옴
    9 | 89 | 789
           | 889
           | 989

      | 99 | 899
           | 999
      
 
  i = 1 ~ i = N
  D[1] 첫 째 자리
  -> 1 ~ 0
  D[2]
  */


import java.util.*;

public class Question88 {
    static long mod = 1000000000;
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        long D[][] = new long[N + 1][11];
        //가장 앞자리의 경우의 수를 채움
        for(int i = 1; i <= 9; i++){
            D[1][i] = 1;
        }

        /*
         경우의 수 채우기
        (나의 식)
        if N = 1
            D[1] = 9
        else
            D[1] = 10
            N[1] = for(number = 0 ~ 9)
                for i = 2 ~ N
                    1) i = 2
                        if(N[2 - 1] == 0)
                            D[2] = 2
                            N[2] = N[1] or N[1] + 1
                        else if(N[2 - 1] == 9)
                            D[2] = 2
                            N[2] = N[1] or N[1] - 1
                        else
                            D[2] = 3
                            N[2] = N[1] - 1 or N[1] or N[1] + 1

                    2) i = 3
                        if(N[3 - 1] == 0 or 9)
                            D[3] = 2
                        else
                            D[3] = 3 
            0, 9 | 1~8을 다르게 처리해야하는 것을 알고 있었음
            하지만 처리하는 걸 if문으로 복잡하게 처리함 -> 저거는 재귀식에서나 쓰지 for 문은 다름. 
            저장되는 걸 처리하는걸 아직 잘 못하는 듯.

         */
        for(int i = 2; i <= N; i++){
            D[i][0] = D[i - 1][1];
            D[i][9] = D[i - 1][8];
            for(int j = 1; j <= 8; j++){
                D[i][j] = (D[i - 1][j - 1] + D[i - 1][j + 1]) % mod;
            }
        }
        long sum = 0;
        for(int i = 0; i <= 9; i++){
            sum = (sum + D[N][i]) % mod;
        }
        System.out.println(sum);
        

       
    }
}
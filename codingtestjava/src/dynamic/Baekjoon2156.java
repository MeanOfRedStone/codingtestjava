package dynamic;

/*
 <출제 포인트 및 풀이 평가>
 (1) 동적 계획법
 작은 부분으로 큰 부분의 문제를 어떻게 해결할 것인가
 N 값이 문제를 부분 문제로 나누는 역할을 해야함

 (2) 점화식 90% 잘 세움
 -> 제일 마지막에서 문제를 해결해야하므로 D[i] 구할 때 D[i-1]이 제일 큰 경우도 생각해봐야 한다. 
 -> D[i-3] 이하로 안내려가는 경우 어짜피 포함되어있다. (점화식이므로)

 (3) 동적 계획법은 항상 n 작을 때 에러 나는지 확인해야 한다.!

 */


/*
 1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
 2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

 6, 10, 13, 9, 8, 1

 (1) 작은 부분으로 큰 부분의 문제를 어떻게 해결할 것인가
  N 값이 문제를 부분 문제로 나누는 역할을 해야함

  D[1] :   6  1을 포함하고 길이가 1만큼일 때 최대의 포도주 선택 -> 6         A[1]
  D[2] :  16  2를 포함하고 길이가 2만큼일 때 최대의 포도주 선택 -> 6 ,10 = 16         (A[1] + A[2])
  D[3] :  23 3을 포함하고 길이가 3일 때 최대의 포도주 선택(연속 3개 안되므로 앞 2개중 max 선택) 10, 13      D[1] + A[3] | (A[2] + A[3])     -> D[3] = A[2] + A[3]
                                                                                                    D[1] + A[3] | (A[2] + A[3])
  D[4] :  28 4를 포함하고 길이가 4일 때 최대의 포도주 선택 6, 10 , ㅇㅇ,  9  | 6, ㅇㅇ, 13, 9)  :      A[1] + A[2] + A[4] | A[1] + (A[3] + A[4])  -> D[4] = D[1] + (A[3] + A[4])
                                                                                                    D[2] + A[4]         D[1] + (A[3] + A[4])  
  D[5] :  33                                                                               A[2] + A[3] + A[5]       A[1] + A[2] + (A[4] + A[5])  -> D[5] = D[2] + (A[4] + A[5]) 
                                                                                        D[3] + A[5]                 D[2] + (A[4] + A[5])
  D[6] :  32    1  A[2] + A[3] + A[6]  |  A[1] + A[3] + A[4] + A[6]  | A[1] + A[2] + A[5] + A[6]   |  A[2] + A[3] + A[5] + A[6]
            D[3] + A[6]                 D[4] + A[6]                 D[1] + (A[5] + A[6])        D[3] + (A[5] + A[6])
            
  D[1] =  A[1]
  D[2] =  (A[1] + A[2])
  D[3] =  D[1] + A[3] | (A[2] + A[3])  -> D[0] + (A[2] + A[3]) 
  D[4] =  D[2] + A[4] |  D[1] + (A[3] + A[4])       ->  D[1] + (A[3] + A[4]) 
  D[5] =  D[3] + A[5]  |  D[2] + (A[4] + A[5])       ->  D[2] + (A[4] + A[5])
  D[6] =  D[4] + A[6]  |  D[2] + (A[5] + A[6])  |  D[3] + (A[5] + A[6])   -> D[3] + (D[5] + D[6]) 
  
  D[i] = D[i-1]
  D[i] = D[i-2] + A[i]  
  D[i] = D[i-3] + A[i-1] + A[i]
 */                                                                         

import java.util.*;

public class Baekjoon2156 {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int wine[] = new int[n + 1];
        int D[] = new int[n+1];
        wine[0] = 0;
        for(int i = 1; i < n + 1; i++){
            wine[i] = sc.nextInt();
        }

        D[0] = wine[0];
        D[1] = wine[1];
        if(n > 1){
            D[2] = wine[1] + wine[2];
        }
        
        for(int i = 3; i < n + 1; i++){
            D[i] = Math.max(D[i-1], Math.max(D[i-2] + wine[i], D[i-3] + wine[i-1] + wine[i]));
        }

        System.out.println(D[n]);
    }
}
